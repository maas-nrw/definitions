@startuml
'https://plantuml.com/class-diagram
'skinparam nodesep 10
'skinparam ranksep 20




package router as "router = intermodal (Meta) Router"{
    package routing_graph {
        interface JourneyRating {
            int rate_journey_by_requirements(RoutingRequestParams params)
        }


        abstract class RouterNode {
            Place place
        }

        abstract class RouterEdge {
            start_node RouterNode
            end_node RouterNode
            RouterEdgeStatus status()
            Journey[] journey_options()
        }

        enum RouterEdgeStatus {
            REQUESTED
            DATA_GATHERED
            MERGED
            OPTIMIZED
        }
    }

    package route_calculation {
            class RouteCalculationNode {
                RoutingRequestParams params
                DateTime planned_arrival_time, planned_departure_time
                Place origin
                Place destination
                int air_line_distance_to_origin()
                int air_line_distance_to_destination()
                RouterNodeStatus status

                RouterEdge[] retrieve_edges(target_node)
                Journey[] journey_options()
            }
        enum RouteCalculationStatus {
            REQUESTED
            PROPOSED
            PLANNED
            STARTED
            TRAVELLED
        }

    }

}
router --[hidden]> mobility_data_broker
note top of router: "Corresponds to package "router" in python structure"

package mobility_data_broker {

    package broker_core {
        enum RequestStatus {
            INITIALIZED
            REQUESTED
            EXECUTED
        }

        abstract class RequestBrokerNode {
            params RoutingRequestParams
            async retrieve_data()
            async execute()
        }
    }

    package routing_model_core {
        enum RoutingModality {
            INTERMODAL
            PUBLIC_TRANSPORT
            BIKE
            FOOT
            CAR
        }


        enum EngineType {
            MUSCLE
            ELECTRIC
            FUELED
        }
        enum FuelType {
            Benzin
            Diesel
            H2
            eFuel
            LPG
            LNG
        }
        class TransportProduct {
            String id, name, description
            OwnershipType owner
        }

        enum OwnershipType {
            OWNED_BY_TRAVELLER
            RENTED_OPERATED_BY_TRAVELLER
            SERVICE_OPERATED_BY_TRANSPORT_OPERATOR
        }

        abstract class RoutingLeg {
            Place origin
            Place destination
            int air_line_distance_m
            int duration_travelled
            Waypoint[] waypoints
            RoutingModality modality
            MobilityProduct product
            int transport_duration_secs_estimated
        }
        abstract class PrivateTransportRoutingLeg {
           int distance_travelled_m
        }

        PrivateTransportRoutingLeg ---|> RoutingLeg

        note top of RoutingLeg
            A routing leg is (by our definition and
            not exactly matching to what we find in
            current implementations) a POTENTIAL part
            of a journey and (rgf. the base class) not
            a PLANNED or ACTUAL part.
            The PLANNED of ACTUAL insertion of a RoutingLeg
            into a journey is represented by the
             RoutingLegJourneyWrapper.
        end note

        interface RoutingLegJourneyContext {
            int leg_idx
            Journey journey
            DateTime start_time
            int make_ready_time_secs
            DateTime departure_time
            int duration_total_secs()
            int duration_journey_total_secs()
            DateTime arrival_time


        }
        note top of RoutingLegJourneyContext
            **make_ready_time_secs** is the time between 'start_time' (the preceeding parts of the journey are "finished",
            i.e. the arrival_time of the previous leg or the start of the total journey if there is no previous leg)
            and actual time the journey can be continued using the transport described within this leg
            Resons for having a make_ready_time > 0 can be one or a combination of the following:
               a) scheduled or estimated waiting time until the transport product of leg is available (e.g.
                waiting time until a train or bus arrives in case of using public_transport - or time needed
                until a rented bike is "available" at the origin location of the leg)
               b) "preparation time" for preparing the product used to be "ready to move" (e.g. time needed to pick
               up a bike if it is locked somewhere or in case of )
        end note
        note top of RoutingLegJourneyContext
            There is no interface keyword in python -
            we implement interfaces as abstract classes
            deriving from abc.ABCMETA and implementing
            __subclasshook__,
            see https://realpython.com/python-interface/
        end note
        RoutingLeg <|--- RoutingLegJourneyWrapper
        RoutingLegJourneyContext <|--- RoutingLegJourneyWrapper
        class Journey {
            RoutingLegJourneyWrapper[] legs()
            RouteStatus status()
        }
    }

    package routing_topology {
        package geography {
            class Coords {
                int distance_m(Coords coords)
            }
        }

        enum RoadType {
            ASPHALT
            ROAD
            AUTOBAHN
            RAIL
            FOOTPATH
            BIKEPATH
        }
    }

    package request_parameters {
        abstract class AbstractRoutingRequestParams {
            TransportProduct[] allowed_products()
            RoadType[] road_restrictions()
            EngineType[] engine_restrictions()
            FuelType[] fuel_restrictions()
            RoutingModality[] modality()
        }
        AbstractRoutingRequestParams <|-- GeneralRoutingRequestParams
        AbstractRoutingRequestParams <|-- BikeSpecificRoutingRequestParams
        AbstractRoutingRequestParams <|-- PublicTransportSpecificRoutingRequestParams
        AbstractRoutingRequestParams <|-- PublicTransportCombinedWithBikeSpecificRoutingRequestParams

        interface IntermodalRoutingRequestParams {
            GeneralRoutingRequestParams general_routing_params()
            AbstractRoutingRequestParams routing_params_by_modality(RoutingModality)
            AbstractRoutingRequestParams routing_params_for_first_mile()
            AbstractRoutingRequestParams routing_params_for_last_mile()
        }
    }

    package broker_plugin_bicycle_routing {
            class BikeRoutingLeg {
            }
            BikeRoutingLeg ---|> PrivateTransportRoutingLeg
    }

    package broker_plugin_public_transport {
        class DelfiRoutingLeg {
            DateTime transport_start_time_estimated
            DateTime transport_start_time_scheduled
            int transport_duration_secs_estimated

        }
        DelfiRoutingLeg ---|> RoutingLeg
        note top of DelfiRoutingLeg
            A delfi routing leg implements the
            journey context interface - as it is always
            calculated as part of a potential journey
        end note
        class DelfiRoutingLegJourneyWrapper {
        }
        RoutingLegJourneyWrapper <|--- DelfiRoutingLegJourneyWrapper
        DelfiRoutingLeg <|--- DelfiRoutingLegJourneyWrapper

    }
}
' Dependencies between packages are modelled outside of the package:

RouterNode <|-- Waypoint
RouterEdge <|-- RoutingLeg
RouterEdge <|-- RequestedRoute


note top of mobility_data_broker: Corresponds to package mobility_data_broker,\ncurrently part of router repo. Subject to change -\n shall be own git project as soon as refactoring stable.\nWill be superseeded by ZMDZ Request Broker as\nsoon as this is developed by external party


@enduml